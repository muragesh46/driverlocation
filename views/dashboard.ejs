<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dispatch Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
    <style>
        #map {
            height: 500px;
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .driver-online {
            color: #28a745;
        }
        .driver-offline {
            color: #dc3545;
        }
        .stop-completed {
            text-decoration: line-through;
            color: #6c757d;
        }
        .route-card {
            margin-bottom: 1rem;
        }
        .status-badge {
            font-size: 0.8em;
        }
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            padding: 10px 15px;
            border-radius: 25px;
            color: white;
            font-size: 0.9em;
        }
        .connection-online {
            background: #28a745;
        }
        .connection-offline {
            background: #dc3545;
        }
    </style>
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container">
        <a class="navbar-brand" href="/">üöõ Dispatch Central</a>
        <div class="navbar-nav ms-auto">
            <a class="nav-link" href="/create-route">Create Route</a>
            <a class="nav-link" href="/drivers">Drivers</a>
        </div>
    </div>
</nav>

<!-- Connection Status Indicator -->
<div id="connectionStatus" class="connection-status connection-offline">
    üî¥ Connecting...
</div>

<div class="container mt-4">
    <div class="row">
        <!-- Live Map -->
        <div class="col-md-8">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5>Live Driver Tracking</h5>
                    <div class="d-flex gap-2">
                        <button class="btn btn-sm btn-outline-primary" onclick="refreshMap()">üîÑ Refresh</button>
                        <button class="btn btn-sm btn-outline-success" onclick="fitAllMarkers()">üìç Fit All</button>
                    </div>
                </div>
                <div class="card-body">
                    <div id="map"></div>
                    <div class="mt-2 d-flex justify-content-between">
                        <small class="text-muted">
                            <span id="driverCount">0</span> drivers tracked ‚Ä¢
                            <span id="lastUpdate">Never</span>
                        </small>
                        <small class="text-muted">
                            üîµ Active Routes ‚Ä¢ üü¢ Completed Stops ‚Ä¢ üìç Driver Locations
                        </small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Routes & Driver Status -->
        <div class="col-md-4">
            <div class="card">
                <div class="card-header d-flex justify-content-between">
                    <h5>Active Routes</h5>
                    <a href="/create-route" class="btn btn-sm btn-primary">+ New Route</a>
                </div>
                <div class="card-body" style="max-height: 500px; overflow-y: auto;">
                    <% if (routes.length === 0) { %>
                        <p class="text-muted">No routes created yet.</p>
                        <div class="text-center">
                            <a href="/create-route" class="btn btn-primary">Create First Route</a>
                        </div>
                    <% } else { %>
                        <% routes.forEach(route => { %>
                            <div class="card route-card" data-route-id="<%= route._id %>">
                                <div class="card-body p-3">
                                    <h6 class="card-title d-flex justify-content-between">
                                        <%= route.name %>
                                        <span class="badge bg-<%= route.status === 'active' ? 'success' : route.status === 'completed' ? 'primary' : 'secondary' %> status-badge">
                                            <%= route.status %>
                                        </span>
                                    </h6>
                                    <p class="card-text mb-2">
                                        <strong>Driver:</strong>
                                        <span class="driver-status" data-driver-id="<%= route.driver ? route.driver._id : '' %>">
                                            <%= route.driver ? route.driver.name : 'Unassigned' %>
                                            <span class="status-indicator">
                                                <%= route.driver && route.driver.isActive ? 'üü¢' : 'üî¥' %>
                                            </span>
                                        </span>
                                    </p>
                                    <p class="card-text small mb-2">
                                        <strong>Progress:</strong>
                                        <span class="progress-text">
                                            <%= route.stops.filter(s => s.status === 'completed').length %>/<%= route.stops.length %> stops
                                        </span> |
                                        <strong>Distance:</strong> <%= route.totalDistance %> |
                                        <strong>ETA:</strong> <%= route.estimatedTime %>
                                    </p>

                                    <!-- Progress Bar -->
                                    <div class="progress mb-2" style="height: 6px;">
                                        <div class="progress-bar bg-success"
                                             style="width: <%= (route.stops.filter(s => s.status === 'completed').length / route.stops.length) * 100 %>%">
                                        </div>
                                    </div>

                                    <div class="stops-list">
                                        <small class="text-muted">Recent stops:</small>
                                        <% route.stops.slice(0, 3).forEach((stop, index) => { %>
                                            <div class="small <%= stop.status === 'completed' ? 'stop-completed' : '' %>">
                                                <%= index + 1 %>. <%= stop.address.substring(0, 30) %><%= stop.address.length > 30 ? '...' : '' %>
                                                <% if (stop.status === 'completed') { %>
                                                    ‚úÖ
                                                <% } %>
                                            </div>
                                        <% }); %>
                                        <% if (route.stops.length > 3) { %>
                                            <small class="text-muted">... and <%= route.stops.length - 3 %> more</small>
                                        <% } %>
                                    </div>
                                    <div class="mt-2">
                                        <button class="btn btn-sm btn-outline-info" onclick="focusRoute('<%= route._id %>')">
                                            üìç View on Map
                                        </button>
                                        <% if (route.driver) { %>
                                            <button class="btn btn-sm btn-outline-success ms-1" onclick="trackDriver('<%= route.driver._id %>')">
                                                üîç Track Driver
                                            </button>
                                        <% } %>
                                    </div>
                                </div>
                            </div>
                        <% }); %>
                    <% } %>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="/socket.io/socket.io.js"></script>

<script>
    // Global variables
    let map;
    let socket;
    let driverMarkers = {};
    let routePolylines = {};
    let stopMarkers = {};
    let isConnected = false;

    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', function() {
        initializeMap();
        initializeSocket();
        loadInitialData();

        // Auto-refresh every 30 seconds
        setInterval(loadInitialData, 30000);
    });

    // Initialize Leaflet map
    function initializeMap() {
        console.log('Initializing map...');

        // Create map centered on New York (adjust coordinates as needed)
        map = L.map('map').setView([40.7128, -74.0060], 11);

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        console.log('Map initialized successfully');
    }

    // Initialize Socket.IO connection
    function initializeSocket() {
        console.log('Initializing socket connection...');

        socket = io();

        socket.on('connect', () => {
            console.log('Connected to server');
            isConnected = true;
            updateConnectionStatus();
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            isConnected = false;
            updateConnectionStatus();
        });

        // Listen for real-time driver location updates
        socket.on('driver-location', (data) => {
            console.log('Received driver location update:', data);
            updateDriverLocation(data.driverId, data.lat, data.lng, data.timestamp);
            updateDriverStatus(data.driverId, true);
        });

        // Listen for stop completion updates
        socket.on('stop-update', (data) => {
            console.log('Received stop update:', data);
            updateStopStatus(data.routeId, data.stopIndex, data.status);
        });
    }

    // Load initial data (routes and driver locations)
    async function loadInitialData() {
        console.log('Loading initial data...');

        try {
            // Load current driver locations
            const response = await fetch('/api/locations');
            if (response.ok) {
                const locations = await response.json();
                console.log('Loaded locations:', locations);

                // Clear existing markers
                Object.values(driverMarkers).forEach(marker => {
                    map.removeLayer(marker);
                });
                driverMarkers = {};

                // Add driver markers
                locations.forEach(location => {
                    if (location.lat && location.lng) {
                        updateDriverLocation(location._id, location.lat, location.lng, location.timestamp);
                    }
                });

                updateDriverCount(locations.length);
            } else {
                console.error('Failed to load locations:', response.status);
            }

            // Draw routes on map
            drawRoutes();

            updateLastUpdate();

        } catch (error) {
            console.error('Error loading initial data:', error);
        }
    }

    // Draw all routes on the map
    function drawRoutes() {
        console.log('Drawing routes...');

        <% routes.forEach(route => { %>
        <% if (route.stops && route.stops.length > 0) { %>
        drawRoute('<%= route._id %>', [
            <% route.stops.forEach((stop, index) => { %>
            {
                lat: <%= stop.lat %>,
                lng: <%= stop.lng %>,
                address: '<%= stop.address.replace(/'/g, "\\'") %>',
                status: '<%= stop.status %>',
                order: <%= index + 1 %>
            }<%= index < route.stops.length - 1 ? ',' : '' %>
            <% }); %>
        ], '<%= route.name %>', '<%= route.status %>');
        <% } %>
        <% }); %>
    }

    // Draw a single route on the map
    function drawRoute(routeId, stops, routeName, routeStatus) {
        if (stops.length < 2) return;

        // Remove existing route if it exists
        if (routePolylines[routeId]) {
            map.removeLayer(routePolylines[routeId]);
        }

        // Remove existing stop markers for this route
        if (stopMarkers[routeId]) {
            stopMarkers[routeId].forEach(marker => map.removeLayer(marker));
        }
        stopMarkers[routeId] = [];

        // Create polyline coordinates
        const coordinates = stops.map(stop => [stop.lat, stop.lng]);

        // Draw route polyline
        const routeColor = routeStatus === 'active' ? 'blue' :
            routeStatus === 'completed' ? 'green' : 'gray';

        routePolylines[routeId] = L.polyline(coordinates, {
            color: routeColor,
            weight: 4,
            opacity: 0.7
        }).addTo(map);

        // Add stop markers
        stops.forEach(stop => {
            const isCompleted = stop.status === 'completed';
            const markerColor = isCompleted ? 'green' : 'red';

            // Create custom icon
            const customIcon = L.divIcon({
                className: 'custom-stop-marker',
                html: `<div style="
                    background-color: ${markerColor};
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    border: 2px solid white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-size: 10px;
                    font-weight: bold;
                ">${stop.order}</div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });

            const marker = L.marker([stop.lat, stop.lng], { icon: customIcon })
                .addTo(map)
                .bindPopup(`
                    <strong>Stop ${stop.order}</strong><br>
                    ${stop.address}<br>
                    <small>Status: ${stop.status}</small><br>
                    <small>Route: ${routeName}</small>
                `);

            stopMarkers[routeId].push(marker);
        });
    }

    // Update driver location on map
    function updateDriverLocation(driverId, lat, lng, timestamp) {
        console.log(`Updating driver ${driverId} location:`, lat, lng);

        // Remove existing marker if it exists
        if (driverMarkers[driverId]) {
            map.removeLayer(driverMarkers[driverId]);
        }

        // Create driver marker icon
        const driverIcon = L.divIcon({
            className: 'driver-marker',
            html: `<div style="
                background-color: #007bff;
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 3px solid white;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 12px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            ">üöõ</div>`,
            iconSize: [30, 30],
            iconAnchor: [15, 15]
        });

        // Add new marker
        driverMarkers[driverId] = L.marker([lat, lng], { icon: driverIcon })
            .addTo(map)
            .bindPopup(`
                <strong>Driver Location</strong><br>
                ID: ${driverId.slice(-6)}<br>
                <small>Last update: ${new Date(timestamp).toLocaleTimeString()}</small>
            `);
    }

    // Update driver status in UI
    function updateDriverStatus(driverId, isOnline) {
        const statusElements = document.querySelectorAll(`[data-driver-id="${driverId}"] .status-indicator`);
        statusElements.forEach(element => {
            element.textContent = isOnline ? 'üü¢' : 'üî¥';
        });
    }

    // Update stop status in UI
    function updateStopStatus(routeId, stopIndex, status) {
        // Refresh the page for now (in production, update UI dynamically)
        setTimeout(() => {
            location.reload();
        }, 1000);
    }

    // Update connection status indicator
    function updateConnectionStatus() {
        const statusEl = document.getElementById('connectionStatus');
        if (isConnected) {
            statusEl.className = 'connection-status connection-online';
            statusEl.innerHTML = 'üü¢ Connected';
        } else {
            statusEl.className = 'connection-status connection-offline';
            statusEl.innerHTML = 'üî¥ Disconnected';
        }
    }

    // Update driver count display
    function updateDriverCount(count) {
        document.getElementById('driverCount').textContent = count;
    }

    // Update last update time
    function updateLastUpdate() {
        document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
    }

    // Focus map on specific route
    function focusRoute(routeId) {
        console.log('Focusing on route:', routeId);

        if (routePolylines[routeId]) {
            map.fitBounds(routePolylines[routeId].getBounds(), { padding: [20, 20] });
        } else {
            alert('Route not found on map');
        }
    }

    // Track specific driver
    function trackDriver(driverId) {
        console.log('Tracking driver:', driverId);

        if (driverMarkers[driverId]) {
            const marker = driverMarkers[driverId];
            map.setView(marker.getLatLng(), 15);
            marker.openPopup();
        } else {
            alert('Driver not found on map');
        }
    }

    // Refresh map data
    function refreshMap() {
        console.log('Refreshing map...');
        loadInitialData();
    }

    // Fit all markers in view
    function fitAllMarkers() {
        const allMarkers = [
            ...Object.values(driverMarkers),
            ...Object.values(stopMarkers).flat()
        ];

        if (allMarkers.length > 0) {
            const group = new L.featureGroup(allMarkers);
            map.fitBounds(group.getBounds(), { padding: [20, 20] });
        } else {
            // Default view if no markers
            map.setView([20.5937, 78.9629], 5);
        }
    }
</script>
</body>
</html>